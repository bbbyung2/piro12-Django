<AskDjango>


01.개발환경 구축하기

* 웹 프레임워크의 필요성
웹 서비스의 필요성 - 서버의 역할, 모든 서비스의 근간
만들 수 있는 것 - 웹 서비스, 앱 서버, 챗봇 서비스
웹 프레임워크 - 웹서비스를 만들 때마다 반복되는 것들을 표준화해서 묶어놓음

* 다양한 파이썬 웹프레임워크
- Django : 백엔드 개발에 필요한 거의 모든 기능 제공(full stack framework)
- Flask : 백엔드 개발에 필요한 일부분의 기능 제공(micro framework)
- Pyramid
- Bottle

* Django의 강점
1. Python 생태계(크롤링, 자동화, 머신러닝 코드와 같은 언어)
2. full stack web framework

* 웹서비스 개발파트
- 백엔드 개발 (서비스 중심)
- 서버 운영
- 프론트엔드 개발
- 앱 개발

* 기본 생성된 파일/디렉토리 목록
piro12-Django : 프로젝트명(이름 변경 가능)
manage.py - 명령행을 통해 각종 장고 명령 수행
mysite - 프로젝트명(함부로 수정 x)
__init__.py
settings.py - 현재 프로젝트의 장고 기본설정, 새롭게 지정할 설정들
urls.py - 최상의 URL 설정
wsgi.py - 실서비스에서의 웹서비스 진입점


02. 장고의 주요 구성 요소
* 장고의 주요 기능(본코스)
1. Function Based Views : 함수(호출 가능한 객체)로 HTTP 요청 초리
2. Models : DB와의 인터페이스
3. Templates : 복잡한 문자열 조합을 보다 용이하게 해줌(주로 문자열 조합 목적)
4. Admin : DB 레코드 관리 UI
5. Logging : 다양한 경로로 메세지 로깅
6. Static files : 개발 목적으로의 정적인 파일 관리
7. Message framework : 유저에게 1회성 메세지 노출 목적

* 장고의 주요 기능(별도 코스)
1. Class Based Views : 클래스로 함수 기반 뷰 만들기
2. Forms : 입력폼 생성, 입력값 유효성 검사 및 DB로의 저장
3. 테스팅
4. 국제화 & 지역화
5. 캐싱
6. Geographic : 위치 검색 기능(DB의 Geo 기능 활용 - PostgreSQL 중심)
7. Sending Emails
8. Syndication Feeds (RSS/Atom)
9. Sitemaps

* 웹 애플리케이션 기본 구조
클라이언트 - 웹 브라우저
서버 - 프레임워크로 만드는 웹 서버(Django), DB 서버, 캐시 서버

웹 서버(Django) - URLConf : URL 별로 호출할 함수를 리스트에 등록
              - 뷰 : URL에 맞춰 호출된 함수(모델을 통해 DB서버와 인터페이싱)
              - 모델 : 파이썬 코드로 DB와 통신
              - 템플릿 엔진 : 복잡한 문자열을 손쉽게 조합(문자열 렌더링 엔진)

* 모델 예시
shop/models.py
from django.db import models
class Item(models.Model):
    name = models.CharField(max_length=100)
    desc = models.TextField(blank=True)    # blank=True : 빈칸이어도 된다다
    price = models.PositiveIntegerField()
    created_at = models.DateTimeField(auto_now_add=True)   # auto_now_add : add될 당시의 현재 시간 자동 저장
    updated_at = models.DateTimeField(auto_now=True)   # auto_now : 저장될 때마다 시간 자동 저장

* URLConf 예시
shop/urls.py
from django.urls import path
from shop import views
app_name = 'shop'
urlpatterns = [
    path('shop/', views.item_list),     # URL과 함수 연결
]

* 뷰 예시
장고앱1/views.py
from django.shortcuts import render from shop.models import Item
def item_list(request):
    qs = Item.objects.all()    # DB로부터 Item목록을 Fetch할 예정
    return render(request, 'shop/item_list.html', {
        'item_list': qs,
    })

* 템플릿 예시
shop/templates/shop/item_list.html


03. 장고 앱
* 장고 앱의 필요성
현재 프로젝트의 블로그 기능을 다른 프로젝트에서도 사용하려할 때(장고 앱 형태로 격리)
python manage.py startapp <앱이름>  :  기본 앱템플릿 생성 명령
재사용성을 목적으로 한 파이썬 패키지(앱이름은 현재 프로젝트에서 유일해야 함)
새롭게 생성한 장고앱, 외부 라이브러리 형태의 장고앱은 꼭 settings.INSTALLED_APPS에 등록시켜줘야 함

* models/views 모듈을 패키지로 전환?
모듈 : 파이썬 소스코드 파일
패키지 : 파이썬 소스코드 디렉토리
1. shop/models.py 내 Item모델, Review모델
2. shop/models/  - __init__.py에서 from .item import *와 같이 임포트(모델 외부에서는 1과 동일하게 사용 가능)


04. VSCode 장고 디버깅 세팅하기
* 디버깅의 필요성
* VSCode의 디버깅
runserver 서버 시작옵션 : --noreload, --nothreading (소스코드를 변경해도 자동 재시작x)
*Pylint 메세지
- C0103 : 타입에 맞지않는 네이밍을 썼을 때
- C0111 : docstring을 정의하지 않았을 때
- C0301 : 1줄 글자수를 초과했을 때
    • max-line-length 옵션 디폴트 : 80
    • PEP8에서는 1줄 최대 79자로 제한
- C0326 : 공백을 잘못 입력했을 때

* pylint Error 대응하기
pip를 통해 pylint-django 설치(pip install pylint-django)
vscode의 설정에 pylintArgs 옵션을 적용


05.URLConf와 정규 표현식
* 정규 표현식
거의 모든 프로그래밍 언어에서 지원
문자열의 패턴, 규칙을 정의
장고 URL Dispatcher에서는 정규표현식을 통한 URL 매칭
문법 : 1글자에 대한 패턴 + 연속된 출연 횟수 지정, 대괄호 내에 1글자에 대한 후보 글자들 나열

* 다양한 정규 표현식 패턴 예시
1자리 숫자 : [0123456789], [0-9], [\d]
2자리 숫자 : [0123456789][0123456789], [0-9][0-9], \d\d
3자리 숫자 : \d\d\d, \d{3}
2자리~4자리 숫자 : \d{2, 4}
휴대폰 번호 : 010[1-9]\d{7}
알파벳 소문자 1글자 : [a-z]

* 반복횟수 지정 문법
r"\d" : 1회 반복
r"\d{2}" : 2회 반복
r"\d{2}" : 2회 반복
r"\d{2, 4}" : 2~4회 반복
r"\d?" : 0회 혹은 1회 반복
r"\d*" : 0회 이상 반복
r"\d+" : 1회 이상 반복

* URL Dispatcher
특정 URL 패틴 -> View의 List
프로젝트/settings.py에서 최상위 URLConf 모듈을 지정
HTTP 요청이 들어올 때마다 URL 매칭 시도
    매칭이 되는 URL Rule이 다수 존재하더라도 처음 Rule만을 사용
    매칭 안되면 404 Page Not Found 응답 발생

* path() 와 re_path()
정규표현식에서 문자의 시작 : ^
        문자의 끝 : $
URL 뒤에는 꼭 / 붙여주기

* 기본 제공되는 Path Converters
- StringConverter : r"[^/]+"
- IntConverter : r"[0-9]+"
- SlugConverter : r"[-a-zA-Z0-9_]+"
- UUIDConverter : -을 포함한 총 36개의 패턴
    r"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
- PathConverter : r".+"

* 커스텀 Path Converter
to_python : url로부터 추출한 문자열을 뷰에 넘겨주기 전에 변환
to_url : url reverse 시에 호출

* 새로운 장고 앱을 생성할 때, 추천 작업
1. 앱 생성
2. 앱이름/urls.py 파일 생성
3. 프로젝트/urls.py에 include 적용
4. 프로젝트/settings.py의 INSTALLED_APPS에 앱 이름 등록


06.다양한 응답의 함수 기반 뷰 만들기
* View
1개의 HTTP 요청에 대해 1개의 뷰가 호출
urls.py/urlpatterns 리스트에 매핑된 호출 가능한 객체(함수도 가능)
웹 클라이언트로부터의 HTTP 요청을 처리
- 2가지 형태의 뷰
함수 기반 뷰 - 기본
클래스 기반 뷰 - 클래스.as_view()를 통해 생성, 리턴

* View 호출 시 인자(HttpRequest 객체 및 URL Captured Values)
1번째 인자 : HttpRequest 객체(현재 요청에 대한 모든 내역)
2번째~ 인자 : 현재 요청의 URL로부터 Capture된 문자열들
    url/re_path를 통한 처리 - 모든 인자는 str 타입
    path를 통한 처리 - 매핑된 Converter의 to_python에 맞게 변환된 값이 인자로 전달

* View 호출에 대한 리턴값(HttpResponse 객체)
필히 HttpResponse 객체를 리턴해야 함
파일like객체 혹은 str/bytes 타입의 응답 지원
파일 like 객체 : response.write(str객체 또는 bytes객체)

*HttpRequest와 HttpResponse 예시
- 요청
request.method : 현재의 요청이 GET인지 POST인지 알 수 있음
request.META : 현재 요청에 대한 META정보
request.GET, request.POST, request.FILES, request.body
- 응답
response = HttpResponse(content)  : 원시적인 방법
response.write(content)
response['Custom-Header'] = 'Custom Header Value'
return response

* FBV의 예(Item 목록 보기)
qs = Item.objects.all()   - 모든 Item 목록을 가져올 준비까지만 함(쿼리셋을 통해 레코드에 접근하고자할 때 가져옴)

* 클래스 기반의 호출 가능한 객체

* Excel 파일 다운로드 응답
파일 like 객체를 지정하면, 내부적으로 읽기를 시도(굳이 f.read()를 호출할 필요 x
with open(filepath, 'rb') as f:
    response = HttpResponse(f, content_type='application/vnd.ms-excel')

* Pandas를 통한 CSV 응답 생성
content_type='text/csv'

* Pandas를 통한 엑셀 응답 생성
content_type='application/vnd.ms-excel'

* Pillow를 통한 이미지 응답 생성


07.적절한 HTTP 상태코드로 응답하기
* HTTP 상태코드
웹 서버는 적절한 상태코드로 응답해야 함
각 HttpResponse 클래스마다 고유한 status_code가 할당
REST API(Web API)를 만들 때 특히 유용

* 대표적인 상태코드
- 200번대 : 성공(200)
- 300번대 : 요청을 마치기 위해 추가 동작을 취해야 함
- 400번대 : 클라이언트 측 오류
- 500번대 : 서버 측 오류

* 200에 응답하는 몇 가지 예
HttpResponse(문자열, 엑셀, 이미지 데이터)
render
JsonResponse

* 302에 응답하는 몇 가지 예
HttpResponseRedirect : URL reverse 적용(특정 앱의 namespace의 패턴이 실제로 가리키는 URL을 찾아줌)
redirect

* 404에 응답하는 몇 가지 예
Item.objects.get
except Item.DoesNotExist:
    raise Http404
    or
    return HttpResponseNotFound()   : 잘 안 씀

* 500에 응답하는 몇 가지 예(뷰에서 미처 잡지못한 오류)
지정 조건의 Item 레코드가 없을 때, 2개 이상 있을 때


08.장고 쉘
* 장고 프로젝트 설정이 로딩된 파이썬 쉘
python manage.py shell
우선순위 : ipython, bpython, python
-i : 인터프리터 인터페이스 커스텀 지정
-c : 실행할 파이썬 코드를 문자열로 지정
python -c "print(2**100)"

* django-extensions 내 shell_plus 명령
구동 시에 자동 import

* django-extensions 설치 및 구동
pip install django-extensions
python manage.py shell_plus --notebook : JUpyter Notebook을 통한 실행
커널이 Django Shell-Plus인지 필히 확인

* SQL 출력 옵션
python manage.py shell_plus --print-sql


09.장고 모델(ORM)
* 애플리케이션의 다양한 데이터 저장방법
데이터베이스 : RDBMS, NoSQL
파일 : 로컬, 외부 정적 스토리지
캐시서버 : memcached, redis

* 데이터베이스와 SQL
RDBMS(관계형 DB 관리 시스템)
NoSQL : MongoDB, ...
DB에 쿼리하기 위한 언어 -> SQL
직접 SQL 만들거나, ORM을 통해 SQL을 생성/실행
중요) ORM 쓰더라도 ORM코드를 최적화할 수 있어야 함
장고 ORM인 모델은 RDB만을 지원

* 다양한 파이썬 ORM
-Relational DB
-NoSQL DB

* 장고의 강점은 Model과 Form
장고에서도 다양한 ORM, 라이브러리 사용 가능
SQL 직접 실행 가능

* Django Model(장고 내장 ORM)
<데이터베이스 테이블>과 <파이썬 클래스>를 1:1로 매핑
    - 모델 클래스 명은 단수형(첫글자가 대문자인 CamelCase 네이밍)
    - 매핑되는 모델 클래스는 DB 테이블 필드 내역이 일치해야 함
    - 서비스에 맞게 DB 설계 필수
    - 필드명은 snake_case

* 모델 활용 순서
- 장고 모델을 통해 DB 형상을 관리할 경우 (주로 사용)
1. 모델 클래스 작성
2. 모델 클래스로부터 마이그레이션 파일 생성 -> makemigrations 명령
3. 마이그레이션 파일을 DB에 적용 -> migrate 명령
4. 모델 활용
- 장고 외부에서, DB 형상을 관리할 경우
DB로부터 모델 클래스 소스 생성 -> inspectdb 명령
모델 활용

* 모델명과 DB 테이블명
DB 테이블명 : 디폴트"앱이름_모델명"
blog앱 : Post모델->"blog_post"

CharField : 길이 제한 있음(max_length로 지정)
TextField : 길이 제한 없음

* 적용 순서
Item 모델 정의
마이그레이션 파일 생성
마이그레이션 파일 적용
DB 확인


10.장고 모델 필드
* 기본 지원하는 모델필드 타입
• Primary Key: AutoField, BigAutoField
• 문자열: CharField, TextField, SlugField(URL로 사용되는 기사 title)
• 날짜/시간: DateField, TimeField, DateTimeField, DurationField
• 참/거짓: BooleanField, NullBooleanField
• 숫자: IntegerField, SmallIntegerField, PositiveIntegerField,
PositiveSmallIntegerfield, BigIntegerField, DecimalField, FloatField
• 파일: BinaryField, FileField, ImageField, FilePathField

* 기본 지원하는 모델필드 타입
• 이메일: EmailField
• URL: URLField
• UUID: UUIDField
• 아이피: GenericIPAddressField
• Relationship Types
• ForeignKey
• ManyToManyField
• OneToOneField
• 그리고, 다양한 커스텀 필드들

* 모델필드들은 DB 필드타입을 반용
Varchar 필드타입 -> CharField, SlugField, URLField, EmailField 등
같은 모델필드여도 DB에 따라 다른 타입으로 생성될수도 있음!

* 자주 쓰는 필드 공통 옵션
• blank : 파이썬 validation시에 empty 허용 여부 (디폴트: False)  - blank, null 모두 False일땐 꼭 값이 있어야 함
• null (DB 옵션) : null 허용 여부 (디폴트: False)
• db_index (DB 옵션) : 인덱스 필드 여부 (디폴트: False)
• default : 디폴트 값 지정, 혹은 값을 리턴해줄 함수 지정
    사용자에게 디폴트값을 제공코자 할 때
• unique (DB 옵션) : 현재 테이블 내에서 유일성 여부 (디폴트: False)
• choices : select 박스 소스로 사용
• validators : validators를 수행할 함수를 다수 지정
    모델 필드에 따라 고유한 validators들이 등록 (ex- 이메일만 받기)
• verbose_name : 필드 레이블, 미지정시 필드명이 사용
• help_text : 필드 입력 도움말

* tip
설계한 DB 구조에 따라 최대한 필드타입을 타이트하게 지정해주는 것이 입력값 오류를 막을 수 있음
ORM은 SQL쿼리를 만들어주는 역할일 뿐, DB엔진에 대한 깊은 이해 필요


11.마이그레이션을 통한 데이터베이스 스키마 관리
*Migrations
- makemigrations : 마이그레이션 파일 생성
- migrate : 지정 DB에 마이그레이션 적용
- showmigrations : 마이그레이션 적용 현황 출력
- sqlmigrate : 지정 마이그레이션의 SQL 내역 출력(실제 DB에 반영은 x)

*Migration 파일
DB에 어떤 변화를 가하는 Operation들 나열(migration만 하면 빈 테이블 생성)
대개 모델로부터 자동 생성 -> makemigrations 명령
    모델 참조없이 빈 마이그레이션 파일 만들어서 직접 채워넣기도 함
주의) 같은 Migration파일이라도 DB종류에 따라 다른 SQL 생성

* 마이그레이션 파일 생성 및 적용
앱/models.py, 마이그레이션 파일, 데이터베이스 서버
모델 변경내역,    마이그레이션 파일,  DB에 적용
            생성된 마이그레이션 파일 내역 확인(의도에 맞게 생성되었는지)
            migrate하지 않은 migration파일은 언제든 삭제하고 새로 만들어도 되지만
            migrate한 migration 파일은 절대 삭제하면 x
모델 변경내역 -> 마이그레이션 파일에 적용 -> DB에 적용
버그 있을 때 롤백해야 하는데 migrate 명령 통해서 함

* 언제 makemigrations를 하는가?
모델 필드 관련된 어떠한 변경이라도 발생 시 마이그레이션 파일 생성(DB Scheme에 변화가 없더라도 수행)
마이그레이션 파일은 모델의 변경내역을 누적하는 역할(적용된 마이그레이션 파일 절대 삭제 x)
squashmigrations 명령으로 통합은 가능

* 마이그레이션 정/역방향
ForeignKey나 OnetooneField에 대해서 on_delete 옵션을 꼭 지정하도록 되어있음
python manage.py migrate <앱이름>
python manage.py migrate <앱이름> <마이그레이션-이름>

* 마이그레이션 이름 지정(1개를 판별할 수 있는 일부만 지정해도 ok)
* 마이그레이션 순서는 파일명으로 정렬순이 아님

* id 필드
모든 DB 테이블에는 각 Row의 식별기준인 기본키가 필요(장고에서는 기본키로 id필드를 디폴트 생성)
다른 필드를 기본키로 지정하고 싶다면 primary_key=True 옵션 적용

* 새로운 필드가 필수필드라면?
필수필드 여부 : blank/null 옵션이 모두 False일 때 (디폴트)
makemigrations 명령을 수행할 때, 기존 Record들에 어떤 값을 채울지 물음

* 협업 Tip
- 팀원 각자 마이그레이션 파일 생성 x (1명이 전담해서 생성)
  다른 팀원들은 이를 받아서 migrate만 수행
- 서버에 아직 반영하지 않은 마이그레이션 다수 생성시?
  하나의 마이그레이션으로 합쳐서 적용!
  방법1) 서버로의 미적용 마이그레이션들을 모두 롤백하고  롤백된
    마이그레이션들을 모두 제거하고  새로이 마이그레이션 파일 생성
  방법2) 미적용 마이그레이션들을 하나로 합치기  squashmigrations


12.장고 Admin을 통한 데이터 관리
* django admin
디폴트 경로 : /admin/ -> 실제 서비스에서는 다른 주소로 변경 권장
서비스 초기에 관리도구로서 사용하기에 제격(관리도구 만들 시간을 줄이고, End-User 서비스에 집중)
내부적으로 Django Form을 적극적으로 사용

* 모델 클래스에 admin 등록하기
등록법1) admin.site.register(Item)
등록법2) class ItemAdmin(admin.ModelAdmin):
        pass
      admin.site.register(Item, ItemAdmin)
등록법3)
@admin.register(Item)
class ItemAdmin(admin.ModelAdmin):
    pass

* 모델 클래스에 __str__ 구현
admin 모델 리스트에서 "모델명 object"를 원하는 대로 변경하기 위해
객체.__str__()의 리턴값 활용

* list_display 속성 정의 (모델 리스트에 출력할 컬럼 지정)
list_display = ['pk', 'name', 'price']  -> 리스트에 들어있는 칼럼 출력

* list_display_links 속성 정의 (어디에 클릭하는 링크가 걸리는지 설정)
list_display 지정된 이름 중에 detail 링크를 걸 속성 리스트

* search_fields 속성 정의 (검색 무엇으로 할지)
admin 내 검색UI를 통해, DB를 통한 where 쿼리 대상 필드 리스트

* list_filter 속성 정의 (필터 옵션 생성)
지정 필드값으로 필터링 옵션 제공


13.모델을 통한 데이터 조회
* Model Manager (DB 질의 인터페이스 제공)
디폴트 Manager로서 ModelCls.objects가 제공
ModelCls.objects.all() - Query Set이 만들어짐 (실행이 지연됨)
ModelCls.objects.create() - 실행이 즉시 됨

*Query Set (순회가능한 객체) Iterable
SQL을 생성해주는 인터페이스
Chaining을 지원해줌
Post.objects.all().filter().exclude().filter()
Query Set은 Lazy한 속성(Query Set을 만드는 동안에는 DB접근 x, 실제로 데이터 필요할 때 접근)
데이터가 필요한 시점 : print(queryset), list(queryset), for instance in queryset: print(instance)

* 다양한 조회요청 방법
- 조건을 추가한 Queryset, 획득할 준비
queryset.filter(...) -> queryset (조건을 여러개 넣을 수 있음) and 이용
queryset.exclude(...) -> queryset - not 이용
- 특정 모델객체 1개 획득을 시도 (DB로의 접근)
queryset[숫자인덱스] -> 모델 객체 혹은 예외발생
queryset.get(...) -> 1개를 가져오겠다 (filter에서 쓰는 조건 똑같이 가능), 모델객체 혹은 0개나 2개 이상 예외발생
queryset.first() -> 모델 객체 혹은 None
queryset.last() -> 모델 객체 혹은 None

* filter <-> exclude
SELECT query에 WHERE 조건 추가
인자로 필드명=조건값 지정
1개 이상의 인자 지정 -> 모두 AND 조건으로 묶임
OR 조건을 묶으려면 django.db.models.Q 활용 (&, |와 같은 비트 연산자 활용)

* 필드 타입별 다양한 조건 매칭 (DB마다 생성되는 SQL이 다름)
- 숫자/날짜/시간 필드 (le, lte, gt, gte)
필드명__lt = 조건값 -> 필드명 < 조건값
- 문자열 필드
필드명__startswith = 조건값 -> 필드명 LIKE "조건값%"

* 정렬 조건 추가 (SELECT 쿼리에 "ORDER BY" 추가)
추가하지 않으면 일관된 순서를 보장받을 수 없음
DB에서 다수 필드에 대한 정렬 지원 (but 단일 필드로 하는 것이 성능에 이익)
시간순/역순 정렬이 필요할 경우 id 필드를 활용 (AutoField)
- 정렬 조건을 지정하는 2가지 방법
1. 모델 클래스의 Meta 속성으로 ordering 설정 : list로 지정 (추천)
2. 모든 queryset에 orderby(...)에 지정

* 정렬 지정하기
1. 모델에서 지정한 경우 (추천)
Item class 안에 Meta class 생성
ordering = ['id'] 오름차순, ['-id'] 내림차순
2. 모델에서 지정 안했을 경우

* Queryset에 범위 조건 추가
- slicing을 통한 범위조건 추가 (SELECT 쿼리에 "OFFSET/LIMIT" 추가)
str/list/tuple 에서의 슬라이싱과 거의 유사 (역순은 x)
객체[start:stop:step]
OFFSET -> start
LIMIT -> stop - start
step은 쿼리에 대응 x (사용 비추천)

* 역순 슬라이싱 대응하기
reversed(qs.reverse()[:10])


14.모델을 통한 데이터 생성/수정/삭제
